%{
#include "stdio.h"
#include "assert.h"
#include "tree.h"
#include "codegen.h"


/** TODO
    Use lea in more places 
        (mul, 2, 3, 4, 5, 8, 9)
    Implement redundant move removal
    research if multiplication is valid with tagged values (seems to be)
    is addition with tagged values correct (negative?)
*/

%}

%start ret
%term OP_VAR=1 OP_NUM=2 OP_ADD=3 OP_SUB=4 OP_MUL=5 OP_AND=6 OP_LT=7 OP_EQ=8 OP_NOT=9 OP_HEAD=10 OP_TAIL=11 OP_ISNUM=12 OP_ISLIST=13 OP_ISFUN=14 OP_RET=15 OP_ZERO=16 OP_ONE=17 OP_LIST=18
%%

ret: OP_RET(u_expr)         # 1 # ret(LEFT_CHILD(bnode), UNTAGGED, TYPE_REG);
ret: OP_RET(const)          # 0 # ret(LEFT_CHILD(bnode), UNTAGGED, TYPE_NUMBER);
ret: OP_RET(var)            # 0 # ret(LEFT_CHILD(bnode),TAGGED, TYPE_REG);
ret: OP_RET(t_expr)         # 1 # ret(LEFT_CHILD(bnode), TAGGED, 0);
ret: OP_RET(t_word)         # 1 # ret(LEFT_CHILD(bnode), TAGGED, 0);
ret: OP_RET(u_list)         # 1 # ret(LEFT_CHILD(bnode), UNTAGGED, TYPE_LIST);


u_expr: const                   # 1 # 
u_expr: t_expr                  # 9 # expect_num(bnode); untag_num_into(bnode->reg, bnode->reg);

u_expr: OP_MUL(u_expr, u_expr)  # 5 # gen_mul(bnode);
u_expr: OP_MUL(u_expr, var)     # 5 # gen_mul(bnode);
u_expr: OP_MUL(var, u_expr)     # 5 # gen_mul(bnode);
u_expr: OP_MUL(var, var)        # 6 # gen_mul(bnode);
u_expr: OP_MUL(u_expr, const)   # 1 # gen_mul(bnode);
u_expr: OP_MUL(const, u_expr)   # 1 # gen_mul(bnode);
u_expr: OP_MUL(var, const)      # 2 # gen_mul_var_const(bnode);
u_expr: OP_MUL(const, var)      # 2 # gen_mul_var_const(bnode);

u_expr: OP_MUL(u_expr, one)     # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));
u_expr: OP_MUL(one, u_expr)     # 0 # make_equal_to(bnode, RIGHT_CHILD(bnode));



u_expr: OP_ISNUM(var)           # 0 # gen_isnum(bnode);

u_expr: OP_EQ(t_word, t_word)   # 2 # gen_eq(bnode);
u_expr: OP_EQ(t_word, const)    # 1 # gen_eq(bnode);
u_expr: OP_EQ(const, t_word)    # 1 # gen_eq(bnode);

u_expr: OP_EQ(t_expr, t_expr)   # 2 # gen_eq(bnode);
u_expr: OP_EQ(const, t_expr)    # 1 # gen_eq(bnode);
u_expr: OP_EQ(t_expr, const)    # 1 # gen_eq(bnode);

u_expr: OP_EQ(u_expr, u_expr)   # 1 # gen_eq(bnode);



t_expr: u_expr                  # 9 # tag_num_into(bnode->reg, bnode->reg, TYPE_NUMBER);

t_expr: OP_NOT(t_expr)          # 1 # gen_not(bnode);

t_expr: OP_ADD(var, var)  # 1 # gen_add(bnode);
t_expr: OP_ADD(t_expr, t_expr)  # 3 # gen_add(bnode);
t_expr: OP_ADD(t_expr, const)   # 2 # gen_add(bnode);
t_expr: OP_ADD(const, t_expr)   # 2 # gen_add(bnode);
t_expr: OP_ADD(var, const)   # 1 # gen_add_var_const(bnode);
t_expr: OP_ADD(const, var)   # 1 # gen_add_var_const(bnode);
t_expr: OP_ADD(var, t_expr)   # 1 # gen_add(bnode);
t_expr: OP_ADD(t_expr, var)   # 1 # gen_add(bnode);

t_expr: OP_ADD(zero, t_expr)    # 0 # make_equal_to(bnode, RIGHT_CHILD(bnode));
t_expr: OP_ADD(t_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));

t_expr: OP_SUB(var, var)  # 1 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, t_expr)  # 3 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, const)   # 2 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(const, t_expr)   # 2 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(var, const)   # 1 # gen_sub_var_const(bnode, TAGGED);
t_expr: OP_SUB(const, var)   # 1 # gen_sub_var_const(bnode, TAGGED);
t_expr: OP_SUB(var, t_expr)  # 1 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, var)  # 1 # gen_sub(bnode, TAGGED);

t_expr: OP_SUB(zero, t_expr)    # 2 # gen_sub(bnode, TAGGED); /*gen_code("TODO: flip sign??");*/
t_expr: OP_SUB(t_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));


t_expr: OP_NOT(neg_t_expr)      # 0 # make_equal_to(bnode, LEFT_CHILD(LEFT_CHILD(bnode)));
t_expr: neg_t_expr              # 5 # gen_not(bnode);
t_expr: neg_t_word              # 5 # gen_not(bnode);

t_expr: OP_AND(var, var)        # 1 # gen_and(bnode, TAGGED);
t_expr: OP_AND(t_expr, t_expr)  # 1 # gen_and(bnode, TAGGED);
t_expr: OP_AND(t_expr, const)   # 1 # gen_and(bnode, TAGGED);
t_expr: OP_AND(const, t_expr)   # 1 # gen_and(bnode, TAGGED);
t_expr: OP_AND(var, const)   # 1 # gen_and_var_const(bnode, TAGGED);
t_expr: OP_AND(const, var)   # 1 # gen_and_var_const(bnode, TAGGED);
t_expr: OP_AND(var, t_expr)  # 1 # gen_and(bnode, TAGGED);
t_expr: OP_AND(t_expr, var)  # 1 # gen_and(bnode, TAGGED);

t_expr: OP_ISLIST(t_word)       # 1 # gen_islist(bnode);
t_expr: OP_ISLIST(t_expr)       # 1 # gen_islist(bnode);

t_word: var                     # 0 #
t_word: OP_NOT(neg_t_word)      # 0 # make_equal_to(bnode, LEFT_CHILD(LEFT_CHILD(bnode)));

neg_t_word: OP_NOT(t_word)      # 0 #
neg_t_expr: OP_NOT(t_expr)      # 0 #

var: OP_VAR                     # 0 #
var: OP_MUL(var, one)           # 0 # expect_num(LEFT_CHILD(bnode)); make_equal_to(bnode, LEFT_CHILD(bnode));
var: OP_MUL(one, var)           # 0 # expect_num(RIGHT_CHILD(bnode)); make_equal_to(bnode, RIGHT_CHILD(bnode));



const: one                  # 0 #
const: zero                 # 0 #
const: OP_NUM               # 0 #
const: OP_ADD(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value + RIGHT_CHILD(bnode)->value);
const: OP_SUB(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value - RIGHT_CHILD(bnode)->value);
const: OP_MUL(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value * RIGHT_CHILD(bnode)->value);
const: OP_AND(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value & RIGHT_CHILD(bnode)->value);
const: OP_LT(const, const)  # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value < RIGHT_CHILD(bnode)->value ? 1 : 0);
const: OP_EQ(const, const)  # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value == RIGHT_CHILD(bnode)->value ? 1 : 0);
const: OP_NOT(const)        # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value ^ 1);
const: OP_ISNUM(const)      # 0 # make_constant(bnode, 1);


one: OP_ONE                 # 0 # make_constant(bnode, 1);

one: OP_ADD(one, zero)      # 0 # make_constant(bnode, 1);
one: OP_ADD(zero, one)      # 0 # make_constant(bnode, 1);

one: OP_SUB(one, zero)      # 0 # make_constant(bnode, 1);

one: OP_MUL(one, one)       # 0 # make_constant(bnode, 1);

one: OP_ISNUM(t_expr)       # 0 # make_constant(bnode, 1);
one: OP_ISNUM(u_expr)       # 0 # make_constant(bnode, 1);

zero: OP_ZERO               # 0 # make_constant(bnode, 0);

zero: OP_MUL(u_expr, zero)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, u_expr)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(t_expr, zero)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, t_expr)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(const, zero)   # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, const)   # 0 # make_constant(bnode, 0);
zero: OP_MUL(t_expr, zero)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, t_expr)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(var, zero)     # 0 # expect_num(LEFT_CHILD(bnode)); make_constant(bnode, 0);
zero: OP_MUL(zero, var)      # 0 # expect_num(RIGHT_CHILD(bnode)); make_constant(bnode, 0);

zero: OP_ADD(zero, zero)    # 0 # make_constant(bnode, 0);

zero: OP_AND(zero, var)  # 0 # expect_num(RIGHT_CHILD(bnode)); make_constant(bnode, 0);
zero: OP_AND(var, zero)  # 0 # expect_num(LEFT_CHILD(bnode)); make_constant(bnode, 0);

zero: OP_ISLIST(const)      # 0 # make_constant(bnode, 0);
zero: OP_ISFUN(const)       # 0 # make_constant(bnode, 0);


u_list: OP_LIST(const, const)   # 0 # gen_list_simple(bnode);
u_list: OP_LIST(var, var) # 0 # gen_list_simple(bnode);
u_list: OP_LIST(var, const)  # 0 # gen_list_simple(bnode);
u_list: OP_LIST(const, var)  # 0 # gen_list_simple(bnode);
u_list: OP_LIST(const, t_expr)  # 0 # gen_list_simple(bnode);
u_list: OP_LIST(t_expr, const)  # 0 # gen_list_simple(bnode);
u_list: OP_LIST(t_expr, t_expr) # 0 # gen_list_simple(bnode);
u_list: OP_LIST(var, t_expr) # 0 # gen_list_simple(bnode);
u_list: OP_LIST(t_expr, var) # 0 # gen_list_simple(bnode);

u_list: OP_LIST(const, u_list)   # 0 # gen_list_prepend(bnode);
u_list: OP_LIST(var, u_list)  # 0 # gen_list_prepend(bnode);
u_list: OP_LIST(t_expr, u_list)  # 0 # gen_list_prepend(bnode);
%%

