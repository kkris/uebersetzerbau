%{
#include "stdio.h"
#include "assert.h"
#include "tree.h"
#include "codegen.h"
%}

%start ret
%term OP_VAR=1 OP_NUM=2 OP_ADD=3 OP_SUB=4 OP_MUL=5 OP_AND=6 OP_LT=7 OP_EQ=8 OP_NOT=9 OP_HEAD=10 OP_TAIL=11 OP_ISNUM=12 OP_ISLIST=13 OP_ISFUN=14 OP_RET=15 OP_ZERO=16 OP_ONE=17
%%

ret: OP_RET(u_expr)         # 1 # ret(LEFT_CHILD(bnode), UNTAGGED, TYPE_REG);
ret: OP_RET(expr)           # 1 # gen_code("foobar");
ret: OP_RET(const)          # 0 # ret(LEFT_CHILD(bnode), UNTAGGED, TYPE_NUMBER);
ret: OP_RET(OP_VAR)         # 0 # move(LEFT_CHILD(bnode)->var_reg, "rax"); gen_code("ret");
ret: OP_RET(t_expr)         # 1 # ret(LEFT_CHILD(bnode), TAGGED, 0);
ret: OP_RET(t_word)         # 1 # ret(LEFT_CHILD(bnode), TAGGED, 0);


u_expr: const                   # 0 # bnode->constant = 1;
u_expr: t_expr                  # 9 # untag(bnode->reg, bnode->reg);

u_expr: OP_ADD(const, u_expr)   # 1 # gen_add(bnode, UNTAGGED);
u_expr: OP_ADD(u_expr, const)   # 1 # gen_add(bnode, UNTAGGED);
u_expr: OP_ADD(u_expr, u_expr)  # 1 # gen_add(bnode, UNTAGGED);
u_expr: OP_ADD(u_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));
u_expr: OP_ADD(zero, u_expr)    # 0 # make_equal_to(bnode, RIGHT_CHILD(bnode));

u_expr: OP_SUB(const, u_expr)   # 1 # gen_sub(bnode, UNTAGGED);
u_expr: OP_SUB(u_expr, const)   # 1 # gen_sub(bnode, UNTAGGED);
u_expr: OP_SUB(u_expr, u_expr)  # 1 # gen_sub(bnode, UNTAGGED);
u_expr: OP_SUB(zero, u_expr)    # 1 # gen_sub(bnode, UNTAGGED);
u_expr: OP_SUB(u_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));


u_expr: OP_MUL(u_expr, const)   # 2 # gen_mul(bnode);
u_expr: OP_MUL(const, u_expr)   # 2 # gen_mul(bnode);
u_expr: OP_MUL(u_expr, u_expr)  # 2 # gen_mul(bnode);
u_expr: OP_MUL(u_expr, one)     # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));
u_expr: OP_MUL(one, u_expr)     # 0 # make_equal_to(bnode, RIGHT_CHILD(bnode));

u_expr: OP_ISNUM(OP_VAR)        # 0 # gen_isnum(bnode);


t_expr: OP_VAR                  # 3 # load_tagged_num(bnode->var_reg, bnode->reg);

t_expr: OP_NOT(t_expr)          # 1 # gen_not(LEFT_CHILD(bnode)->reg, bnode->reg, TAGGED);

t_expr: OP_ADD(OP_VAR, OP_VAR)  # 1 # gen_add(bnode, TAGGED);
t_expr: OP_ADD(t_expr, t_expr)  # 3 # gen_add(bnode, TAGGED);
t_expr: OP_ADD(t_expr, const)   # 2 # gen_add(bnode, TAGGED);
t_expr: OP_ADD(const, t_expr)   # 2 # gen_add(bnode, TAGGED);
t_expr: OP_ADD(zero, t_expr)    # 0 # make_equal_to(bnode, RIGHT_CHILD(bnode));
t_expr: OP_ADD(t_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));

t_expr: OP_SUB(OP_VAR, OP_VAR)  # 1 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, t_expr)  # 3 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, const)   # 2 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(const, t_expr)   # 2 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(zero, t_expr)    # 2 # gen_sub(bnode, TAGGED);
t_expr: OP_SUB(t_expr, zero)    # 0 # make_equal_to(bnode, LEFT_CHILD(bnode));


t_expr: OP_EQ(t_word, t_word)   # 2 # gen_eq_tagged(bnode);
t_expr: OP_EQ(t_word, const)    # 1 # gen_eq_tagged(bnode);
t_expr: OP_EQ(const, t_word)    # 1 # gen_eq_tagged(bnode);

t_expr: OP_EQ(t_expr, t_expr)   # 2 # gen_eq_tagged(bnode);
t_expr: OP_EQ(const, t_expr)    # 1 # gen_eq_tagged(bnode);
t_expr: OP_EQ(t_expr, const)    # 1 # gen_eq_tagged(bnode);

t_expr: OP_EQ(u_expr, u_expr)   # 1 # gen_eq_untagged(bnode);

t_expr: OP_NOT(neg_t_expr)      # 0 # make_equal_to(bnode, LEFT_CHILD(LEFT_CHILD(bnode)));


t_word: OP_VAR                  # 1 #
t_word: OP_NOT(neg_t_word)      # 0 # make_equal_to(bnode, LEFT_CHILD(LEFT_CHILD(bnode)));

neg_t_word: OP_NOT(t_word)      # 0 #
neg_t_expr: OP_NOT(t_expr)      # 0 #




const: OP_ADD(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value + RIGHT_CHILD(bnode)->value);
const: OP_SUB(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value - RIGHT_CHILD(bnode)->value);
const: OP_MUL(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value * RIGHT_CHILD(bnode)->value);
const: OP_AND(const, const) # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value & RIGHT_CHILD(bnode)->value);
const: OP_LT(const, const)  # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value < RIGHT_CHILD(bnode)->value ? 1 : 0);
const: OP_EQ(const, const)  # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value == RIGHT_CHILD(bnode)->value ? 1 : 0);
const: OP_NOT(const)        # 0 # make_constant(bnode, LEFT_CHILD(bnode)->value ^ 1);
const: OP_ISNUM(const)      # 0 # make_constant(bnode, 1);
const: OP_NUM               # 0 #
const: one                  # 0 #
const: zero                 # 0 #


one: OP_ONE                 # 0 # make_constant(bnode, 1);

one: OP_ADD(one, zero)      # 0 # make_constant(bnode, 1);
one: OP_ADD(zero, one)      # 0 # make_constant(bnode, 1);

one: OP_SUB(one, zero)      # 0 # make_constant(bnode, 1);

one: OP_MUL(one, one)       # 0 # make_constant(bnode, 0);

one: OP_ISNUM(t_expr)       # 0 # make_constant(bnode, 1);
one: OP_ISNUM(u_expr)       # 0 # make_constant(bnode, 1);

zero: OP_ZERO               # 0 # make_constant(bnode, 0);

zero: OP_MUL(u_expr, zero)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, u_expr)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(t_expr, zero)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, t_expr)  # 0 # make_constant(bnode, 0);
zero: OP_MUL(const, zero)   # 0 # make_constant(bnode, 0);
zero: OP_MUL(zero, const)   # 0 # make_constant(bnode, 0);

zero: OP_ADD(zero, zero)    # 0 # make_constant(bnode, 0);


%%

